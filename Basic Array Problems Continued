# LEFT ROTATE ARRAY BY ONE PLACE 

## 1. Move Array by One Place

### Problem

Given an array of size **n**, shift all elements **one position to the left**.
The first element moves to the last position.

**Example:**
Input: `[1, 2, 3, 4, 5]`
Output: `[2, 3, 4, 5, 1]`

---

### Brute Force Approach

**Idea:**
Create a new array and manually shift elements.

**Steps:**

1. Create a new array `temp` of size `n`.
2. Copy elements from index `1` to `n-1` into `temp[0]` to `temp[n-2]`.
3. Put the first element at the last index.

**Time Complexity:** O(n)
**Space Complexity:** O(n)

**Code (C++):**

```cpp
#include <bits/stdc++.h>
using namespace std;

void leftRotateByOne(vector<int>& arr, int n) {
    vector<int> temp(n);

    for (int i = 1; i < n; i++) {
        temp[i - 1] = arr[i];
    }

    temp[n - 1] = arr[0];

    for (int i = 0; i < n; i++) {
        arr[i] = temp[i];
    }
}
```

---

### Better Approach

**Idea:**
Store the first element and shift all others left.

**Steps:**

1. Store `arr[0]` in a variable.
2. Shift all elements left.
3. Put stored element at the end.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

**Code (C++):**

```cpp
void leftRotateByOne(vector<int>& arr, int n) {
    int first = arr[0];

    for (int i = 1; i < n; i++) {
        arr[i - 1] = arr[i];
    }

    arr[n - 1] = first;
}
```

---

### Optimal Approach

For **rotation by one**, the better and optimal approaches are the same, because:

* Minimum work required is shifting all elements once.
* Cannot be done in less than O(n) time.

So, the **in-place shifting method** is the optimal solution.

---

## 2. Move Array by K Places (Left Rotation)

### Problem

Rotate the array **left by k positions**.

**Example:**
Input: `[1, 2, 3, 4, 5]`, `k = 2`
Output: `[3, 4, 5, 1, 2]`

---

### Brute Force Approach

**Idea:**
Rotate the array one place, **k times**.

**Steps:**

1. Repeat k times:

   * Store first element.
   * Shift all elements left.
   * Place stored element at end.

**Time Complexity:** O(n × k)
**Space Complexity:** O(1)

**Code:**

```cpp
void leftRotateByK(vector<int>& arr, int n, int k) {
    k = k % n;

    for (int i = 0; i < k; i++) {
        int first = arr[0];

        for (int j = 1; j < n; j++) {
            arr[j - 1] = arr[j];
        }

        arr[n - 1] = first;
    }
}
```

---

### Better Approach (Using Extra Array)

**Idea:**
Store first k elements separately, shift remaining elements, then append stored ones.

**Steps:**

1. Create temp array of size k.
2. Store first k elements.
3. Shift remaining elements to the left.
4. Copy temp elements to the end.

**Time Complexity:** O(n)
**Space Complexity:** O(k)

**Code:**

```cpp
void leftRotateByK(vector<int>& arr, int n, int k) {
    k = k % n;
    vector<int> temp(k);

    for (int i = 0; i < k; i++) {
        temp[i] = arr[i];
    }

    for (int i = k; i < n; i++) {
        arr[i - k] = arr[i];
    }

    for (int i = n - k; i < n; i++) {
        arr[i] = temp[i - (n - k)];
    }
}
```

---

### Optimal Approach (Reversal Algorithm)

**Idea:**
Use **array reversal** to rotate in-place.

**Steps:**

1. Reverse first k elements.
2. Reverse remaining n−k elements.
3. Reverse the whole array.

**Why it works:**
Reversal rearranges segments into rotated order.

---

**Example:**
Array: `[1, 2, 3, 4, 5]`, k = 2

Step 1: Reverse first k
`[2, 1, 3, 4, 5]`

Step 2: Reverse rest
`[2, 1, 5, 4, 3]`

Step 3: Reverse whole
`[3, 4, 5, 1, 2]`

---

**Time Complexity:** O(n)
**Space Complexity:** O(1)

**Code:**

```cpp
#include <algorithm>

void leftRotateByK(vector<int>& arr, int n, int k) {
    k = k % n;

    reverse(arr.begin(), arr.begin() + k);
    reverse(arr.begin() + k, arr.end());
    reverse(arr.begin(), arr.end());
}
```

---

## Quick Comparison Table

| Problem     | Approach       | Time  | Space | Key Idea               |
| ----------- | -------------- | ----- | ----- | ---------------------- |
| Rotate by 1 | Brute          | O(n)  | O(n)  | Use extra array        |
| Rotate by 1 | Better/Optimal | O(n)  | O(1)  | Shift in-place         |
| Rotate by k | Brute          | O(nk) | O(1)  | Repeat single rotation |
| Rotate by k | Better         | O(n)  | O(k)  | Temp array             |
| Rotate by k | Optimal        | O(n)  | O(1)  | Reversal algorithm     |

---

# MOVE ZEROS TO END 

Below is a **clear, placement-oriented explanation** of the three approaches usually taught in this problem.

---

# Move Zeros to End

**Problem:**
Given an array, move all the zeros to the end while maintaining the **relative order of non-zero elements**.

**Example:**
Input: `1 0 2 3 0 4 0 1`
Output: `1 2 3 4 1 0 0 0`

---

# 1. Brute Force Approach

## Idea

* Create a **temporary array**.
* First, store all **non-zero elements**.
* Then fill remaining positions with zeros.

## Steps

1. Create a new array `temp`.
2. Traverse the original array:

   * If element ≠ 0 → push into `temp`.
3. Count how many zeros are needed.
4. Append zeros at the end.

## Time and Space

* Time Complexity: **O(n)**
* Space Complexity: **O(n)** (extra array)

## C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> moveZerosBrute(vector<int> arr) {
    vector<int> temp;

    // store non-zero elements
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != 0)
            temp.push_back(arr[i]);
    }

    // count zeros
    int zeros = arr.size() - temp.size();

    // append zeros
    for (int i = 0; i < zeros; i++) {
        temp.push_back(0);
    }

    return temp;
}

int main() {
    vector<int> arr = {1, 0, 2, 3, 0, 4, 0, 1};
    vector<int> result = moveZerosBrute(arr);

    for (int x : result)
        cout << x << " ";
}
```

---

# 2. Better Approach (Two-Pass, In-Place)

## Idea

* Move all **non-zero elements to the front**.
* Then fill the remaining part with zeros.
* No extra array needed.

## Steps

1. Keep an index `j = 0`.
2. Traverse array:

   * If element ≠ 0:

     * Place it at index `j`.
     * Increment `j`.
3. After loop:

   * Fill remaining indices with `0`.

## Time and Space

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

## C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

void moveZerosBetter(vector<int>& arr) {
    int j = 0;

    // move non-zero elements forward
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != 0) {
            arr[j] = arr[i];
            j++;
        }
    }

    // fill remaining with zeros
    while (j < arr.size()) {
        arr[j] = 0;
        j++;
    }
}

int main() {
    vector<int> arr = {1, 0, 2, 3, 0, 4, 0, 1};
    moveZerosBetter(arr);

    for (int x : arr)
        cout << x << " ";
}
```

---

# 3. Optimal Approach (Two Pointers, Single Pass)

## Idea

* Use **two pointers**.
* Find the **first zero**.
* Swap it with the next non-zero element.

## Steps

1. Find first zero index → `j`.
2. Traverse from `j+1` to end:

   * If element ≠ 0:

     * Swap `arr[i]` and `arr[j]`.
     * Increment `j`.

## Time and Space

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**
* Only **one pass after first zero** → most efficient in practice.

## C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

void moveZerosOptimal(vector<int>& arr) {
    int n = arr.size();
    int j = -1;

    // find first zero
    for (int i = 0; i < n; i++) {
        if (arr[i] == 0) {
            j = i;
            break;
        }
    }

    // if no zero found
    if (j == -1) return;

    // swap with non-zero elements
    for (int i = j + 1; i < n; i++) {
        if (arr[i] != 0) {
            swap(arr[i], arr[j]);
            j++;
        }
    }
}

int main() {
    vector<int> arr = {1, 0, 2, 3, 0, 4, 0, 1};
    moveZerosOptimal(arr);

    for (int x : arr)
        cout << x << " ";
}
```

---

# Quick Comparison

| Approach | Time | Space | Key Idea                |
| -------- | ---- | ----- | ----------------------- |
| Brute    | O(n) | O(n)  | Use extra array         |
| Better   | O(n) | O(1)  | Shift non-zeros forward |
| Optimal  | O(n) | O(1)  | Two-pointer swapping    |

---

# LINEAR SEARCH 

## 1. Brute Force Approach (Basic Linear Search)

### Idea

Check every element one by one until the target is found.

### Code

```cpp
#include <iostream>
using namespace std;

int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;   // return index if found
        }
    }
    return -1;          // not found
}

int main() {
    int arr[] = {4, 2, 7, 1, 9};
    int n = 5;
    int target = 7;

    int result = linearSearch(arr, n, target);

    if (result != -1)
        cout << "Element found at index: " << result;
    else
        cout << "Element not found";

    return 0;
}
```

### Time Complexity

* Best: **O(1)**
* Average: **O(n)**
* Worst: **O(n)**

---

## 2. Better Approach (For Sorted Array)

### Idea

If the array is sorted and current element becomes greater than target, stop searching.

### Code

```cpp
#include <iostream>
using namespace std;

int linearSearchSorted(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target)
            return i;
        else if (arr[i] > target)
            break;   // stop early
    }
    return -1;
}

int main() {
    int arr[] = {1, 3, 5, 7, 9};
    int n = 5;
    int target = 5;

    int result = linearSearchSorted(arr, n, target);

    if (result != -1)
        cout << "Element found at index: " << result;
    else
        cout << "Element not found";

    return 0;
}
```

### Time Complexity

* Best: **O(1)**
* Worst: **O(n)**
* Can stop early in many cases.

---

## 3. Optimal Perspective

For an **unsorted array**, the brute approach is already optimal.

If the array is **sorted**, the optimal method is **Binary Search**.

---

### Binary Search Code (Optimal for Sorted Arrays)

```cpp
#include <iostream>
using namespace std;

int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;

    while (low <= high) {
        int mid = (low + high) / 2;

        if (arr[mid] == target)
            return mid;
        else if (arr[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}

int main() {
    int arr[] = {1, 3, 5, 7, 9};
    int n = 5;
    int target = 7;

    int result = binarySearch(arr, n, target);

    if (result != -1)
        cout << "Element found at index: " << result;
    else
        cout << "Element not found";

    return 0;
}
```

### Time Complexity

* Best: **O(1)**
* Worst: **O(log n)**

---

## Quick Comparison

| Approach         | Array Type | Time Complexity |
| ---------------- | ---------- | --------------- |
| Linear (Brute)   | Unsorted   | O(n)            |
| Linear (Better)  | Sorted     | Up to O(n)      |
| Binary (Optimal) | Sorted     | O(log n)        |

---

# UNION OF TWO SORTED ARRAYS

## Definition

The **union** of two arrays contains:

* All **unique elements**
* From both arrays
* In **sorted order**

Example:

```
A = [1, 2, 3, 4, 5]
B = [2, 3, 5, 6]

Union = [1, 2, 3, 4, 5, 6]
```

---

# 1. Brute Force Approach

## Idea

1. Insert all elements of both arrays into a **set**.
2. A set automatically:

   * Removes duplicates
   * Keeps elements sorted.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> unionBrute(vector<int>& a, vector<int>& b) {
    set<int> s;

    for (int x : a)
        s.insert(x);

    for (int x : b)
        s.insert(x);

    vector<int> result(s.begin(), s.end());
    return result;
}

int main() {
    vector<int> a = {1, 2, 3, 4, 5};
    vector<int> b = {2, 3, 5, 6};

    vector<int> result = unionBrute(a, b);

    for (int x : result)
        cout << x << " ";

    return 0;
}
```

### Complexity

* Time: **O((n + m) log(n + m))**
* Space: **O(n + m)**

---

# 2. Better Approach

## Idea

1. Use a **map or unordered_set**.
2. Insert elements from both arrays.
3. Then extract the unique values.

### Code (using unordered_set)

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> unionBetter(vector<int>& a, vector<int>& b) {
    unordered_set<int> s;

    for (int x : a)
        s.insert(x);

    for (int x : b)
        s.insert(x);

    vector<int> result(s.begin(), s.end());
    sort(result.begin(), result.end());

    return result;
}

int main() {
    vector<int> a = {1, 2, 3, 4, 5};
    vector<int> b = {2, 3, 5, 6};

    vector<int> result = unionBetter(a, b);

    for (int x : result)
        cout << x << " ";

    return 0;
}
```

### Complexity

* Time: **O(n + m)** average
* Sorting: **O(k log k)** (k = unique elements)
* Space: **O(n + m)**

---

# 3. Optimal Approach (Two-Pointer Method)

## Idea

Since arrays are **already sorted**:

* Use two pointers.
* Compare elements and add unique ones.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> unionOptimal(vector<int>& a, vector<int>& b) {
    int i = 0, j = 0;
    vector<int> result;

    while (i < a.size() && j < b.size()) {
        if (a[i] <= b[j]) {
            if (result.empty() || result.back() != a[i])
                result.push_back(a[i]);
            i++;
        } else {
            if (result.empty() || result.back() != b[j])
                result.push_back(b[j]);
            j++;
        }
    }

    // remaining elements
    while (i < a.size()) {
        if (result.empty() || result.back() != a[i])
            result.push_back(a[i]);
        i++;
    }

    while (j < b.size()) {
        if (result.empty() || result.back() != b[j])
            result.push_back(b[j]);
        j++;
    }

    return result;
}

int main() {
    vector<int> a = {1, 2, 3, 4, 5};
    vector<int> b = {2, 3, 5, 6};

    vector<int> result = unionOptimal(a, b);

    for (int x : result)
        cout << x << " ";

    return 0;
}
```

---

## Complexity of Optimal Approach

* Time: **O(n + m)**
* Space: **O(n + m)** (for result)
* No extra data structures

---

## Final Comparison

| Approach               | Time Complexity   | Space  | Best Use Case            |
| ---------------------- | ----------------- | ------ | ------------------------ |
| Brute (set)            | O((n+m) log(n+m)) | O(n+m) | Simple solution          |
| Better (unordered_set) | O(n+m) avg        | O(n+m) | Faster but needs sorting |
| Optimal (two pointers) | O(n+m)            | O(n+m) | Best for sorted arrays   |

---

# INTERSECTION OF TWO SORTED ARRAYS 
