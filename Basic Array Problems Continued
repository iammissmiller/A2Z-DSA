# LEFT ROTATE ARRAY BY ONE PLACE 

## 1. Move Array by One Place

### Problem

Given an array of size **n**, shift all elements **one position to the left**.
The first element moves to the last position.

**Example:**
Input: `[1, 2, 3, 4, 5]`
Output: `[2, 3, 4, 5, 1]`

---

### Brute Force Approach

**Idea:**
Create a new array and manually shift elements.

**Steps:**

1. Create a new array `temp` of size `n`.
2. Copy elements from index `1` to `n-1` into `temp[0]` to `temp[n-2]`.
3. Put the first element at the last index.

**Time Complexity:** O(n)
**Space Complexity:** O(n)

**Code (C++):**

```cpp
#include <bits/stdc++.h>
using namespace std;

void leftRotateByOne(vector<int>& arr, int n) {
    vector<int> temp(n);

    for (int i = 1; i < n; i++) {
        temp[i - 1] = arr[i];
    }

    temp[n - 1] = arr[0];

    for (int i = 0; i < n; i++) {
        arr[i] = temp[i];
    }
}
```

---

### Better Approach

**Idea:**
Store the first element and shift all others left.

**Steps:**

1. Store `arr[0]` in a variable.
2. Shift all elements left.
3. Put stored element at the end.

**Time Complexity:** O(n)
**Space Complexity:** O(1)

**Code (C++):**

```cpp
void leftRotateByOne(vector<int>& arr, int n) {
    int first = arr[0];

    for (int i = 1; i < n; i++) {
        arr[i - 1] = arr[i];
    }

    arr[n - 1] = first;
}
```

---

### Optimal Approach

For **rotation by one**, the better and optimal approaches are the same, because:

* Minimum work required is shifting all elements once.
* Cannot be done in less than O(n) time.

So, the **in-place shifting method** is the optimal solution.

---

## 2. Move Array by K Places (Left Rotation)

### Problem

Rotate the array **left by k positions**.

**Example:**
Input: `[1, 2, 3, 4, 5]`, `k = 2`
Output: `[3, 4, 5, 1, 2]`

---

### Brute Force Approach

**Idea:**
Rotate the array one place, **k times**.

**Steps:**

1. Repeat k times:

   * Store first element.
   * Shift all elements left.
   * Place stored element at end.

**Time Complexity:** O(n × k)
**Space Complexity:** O(1)

**Code:**

```cpp
void leftRotateByK(vector<int>& arr, int n, int k) {
    k = k % n;

    for (int i = 0; i < k; i++) {
        int first = arr[0];

        for (int j = 1; j < n; j++) {
            arr[j - 1] = arr[j];
        }

        arr[n - 1] = first;
    }
}
```

---

### Better Approach (Using Extra Array)

**Idea:**
Store first k elements separately, shift remaining elements, then append stored ones.

**Steps:**

1. Create temp array of size k.
2. Store first k elements.
3. Shift remaining elements to the left.
4. Copy temp elements to the end.

**Time Complexity:** O(n)
**Space Complexity:** O(k)

**Code:**

```cpp
void leftRotateByK(vector<int>& arr, int n, int k) {
    k = k % n;
    vector<int> temp(k);

    for (int i = 0; i < k; i++) {
        temp[i] = arr[i];
    }

    for (int i = k; i < n; i++) {
        arr[i - k] = arr[i];
    }

    for (int i = n - k; i < n; i++) {
        arr[i] = temp[i - (n - k)];
    }
}
```

---

### Optimal Approach (Reversal Algorithm)

**Idea:**
Use **array reversal** to rotate in-place.

**Steps:**

1. Reverse first k elements.
2. Reverse remaining n−k elements.
3. Reverse the whole array.

**Why it works:**
Reversal rearranges segments into rotated order.

---

**Example:**
Array: `[1, 2, 3, 4, 5]`, k = 2

Step 1: Reverse first k
`[2, 1, 3, 4, 5]`

Step 2: Reverse rest
`[2, 1, 5, 4, 3]`

Step 3: Reverse whole
`[3, 4, 5, 1, 2]`

---

**Time Complexity:** O(n)
**Space Complexity:** O(1)

**Code:**

```cpp
#include <algorithm>

void leftRotateByK(vector<int>& arr, int n, int k) {
    k = k % n;

    reverse(arr.begin(), arr.begin() + k);
    reverse(arr.begin() + k, arr.end());
    reverse(arr.begin(), arr.end());
}
```

---

## Quick Comparison Table

| Problem     | Approach       | Time  | Space | Key Idea               |
| ----------- | -------------- | ----- | ----- | ---------------------- |
| Rotate by 1 | Brute          | O(n)  | O(n)  | Use extra array        |
| Rotate by 1 | Better/Optimal | O(n)  | O(1)  | Shift in-place         |
| Rotate by k | Brute          | O(nk) | O(1)  | Repeat single rotation |
| Rotate by k | Better         | O(n)  | O(k)  | Temp array             |
| Rotate by k | Optimal        | O(n)  | O(1)  | Reversal algorithm     |

---

# MOVE ZEROS TO END 

Below is a **clear, placement-oriented explanation** of the three approaches usually taught in this problem.

---

# Move Zeros to End

**Problem:**
Given an array, move all the zeros to the end while maintaining the **relative order of non-zero elements**.

**Example:**
Input: `1 0 2 3 0 4 0 1`
Output: `1 2 3 4 1 0 0 0`

---

# 1. Brute Force Approach

## Idea

* Create a **temporary array**.
* First, store all **non-zero elements**.
* Then fill remaining positions with zeros.

## Steps

1. Create a new array `temp`.
2. Traverse the original array:

   * If element ≠ 0 → push into `temp`.
3. Count how many zeros are needed.
4. Append zeros at the end.

## Time and Space

* Time Complexity: **O(n)**
* Space Complexity: **O(n)** (extra array)

## C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> moveZerosBrute(vector<int> arr) {
    vector<int> temp;

    // store non-zero elements
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != 0)
            temp.push_back(arr[i]);
    }

    // count zeros
    int zeros = arr.size() - temp.size();

    // append zeros
    for (int i = 0; i < zeros; i++) {
        temp.push_back(0);
    }

    return temp;
}

int main() {
    vector<int> arr = {1, 0, 2, 3, 0, 4, 0, 1};
    vector<int> result = moveZerosBrute(arr);

    for (int x : result)
        cout << x << " ";
}
```

---

# 2. Better Approach (Two-Pass, In-Place)

## Idea

* Move all **non-zero elements to the front**.
* Then fill the remaining part with zeros.
* No extra array needed.

## Steps

1. Keep an index `j = 0`.
2. Traverse array:

   * If element ≠ 0:

     * Place it at index `j`.
     * Increment `j`.
3. After loop:

   * Fill remaining indices with `0`.

## Time and Space

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**

## C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

void moveZerosBetter(vector<int>& arr) {
    int j = 0;

    // move non-zero elements forward
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] != 0) {
            arr[j] = arr[i];
            j++;
        }
    }

    // fill remaining with zeros
    while (j < arr.size()) {
        arr[j] = 0;
        j++;
    }
}

int main() {
    vector<int> arr = {1, 0, 2, 3, 0, 4, 0, 1};
    moveZerosBetter(arr);

    for (int x : arr)
        cout << x << " ";
}
```

---

# 3. Optimal Approach (Two Pointers, Single Pass)

## Idea

* Use **two pointers**.
* Find the **first zero**.
* Swap it with the next non-zero element.

## Steps

1. Find first zero index → `j`.
2. Traverse from `j+1` to end:

   * If element ≠ 0:

     * Swap `arr[i]` and `arr[j]`.
     * Increment `j`.

## Time and Space

* Time Complexity: **O(n)**
* Space Complexity: **O(1)**
* Only **one pass after first zero** → most efficient in practice.

## C++ Code

```cpp
#include <iostream>
#include <vector>
using namespace std;

void moveZerosOptimal(vector<int>& arr) {
    int n = arr.size();
    int j = -1;

    // find first zero
    for (int i = 0; i < n; i++) {
        if (arr[i] == 0) {
            j = i;
            break;
        }
    }

    // if no zero found
    if (j == -1) return;

    // swap with non-zero elements
    for (int i = j + 1; i < n; i++) {
        if (arr[i] != 0) {
            swap(arr[i], arr[j]);
            j++;
        }
    }
}

int main() {
    vector<int> arr = {1, 0, 2, 3, 0, 4, 0, 1};
    moveZerosOptimal(arr);

    for (int x : arr)
        cout << x << " ";
}
```

---

# Quick Comparison

| Approach | Time | Space | Key Idea                |
| -------- | ---- | ----- | ----------------------- |
| Brute    | O(n) | O(n)  | Use extra array         |
| Better   | O(n) | O(1)  | Shift non-zeros forward |
| Optimal  | O(n) | O(1)  | Two-pointer swapping    |

---

# LINEAR SEARCH 

# UNION OF TWO SORTED ARRAYS

# INTERSECTION OF TWO SORTED ARRAYS 
