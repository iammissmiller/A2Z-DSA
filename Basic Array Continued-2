# Find Missing Number

## Problem

You are given an array of size **n-1** containing numbers from **1 to n**.
Exactly **one number is missing**.
Find the missing number.

### Example

```
Input:
n = 5
arr = [1, 2, 4, 5]

Output:
3
```

---

# 1. Brute Force Approach

## Idea

For each number from **1 to n**, check if it exists in the array.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int findMissingBrute(vector<int>& arr, int n) {
    for (int i = 1; i <= n; i++) {
        bool found = false;
        for (int j = 0; j < arr.size(); j++) {
            if (arr[j] == i) {
                found = true;
                break;
            }
        }
        if (!found)
            return i;
    }
    return -1;
}

int main() {
    int n = 5;
    vector<int> arr = {1, 2, 4, 5};

    cout << findMissingBrute(arr, n);
}
```

### Complexity

* Time: **O(n²)**
* Space: **O(1)**

---

# 2. Better Approach (Using Hashing)

## Idea

1. Create a frequency array of size `n+1`.
2. Mark the numbers present.
3. The index with zero frequency is the missing number.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int findMissingBetter(vector<int>& arr, int n) {
    vector<int> freq(n + 1, 0);

    for (int x : arr) {
        freq[x] = 1;
    }

    for (int i = 1; i <= n; i++) {
        if (freq[i] == 0)
            return i;
    }
    return -1;
}

int main() {
    int n = 5;
    vector<int> arr = {1, 2, 4, 5};

    cout << findMissingBetter(arr, n);
}
```

### Complexity

* Time: **O(n)**
* Space: **O(n)**

---

# 3. Optimal Approach (Sum Formula)

## Idea

Sum of first `n` natural numbers:

```
n(n+1)/2
```

Subtract the sum of array elements from this.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int findMissingOptimal(vector<int>& arr, int n) {
    int totalSum = n * (n + 1) / 2;
    int arrSum = 0;

    for (int x : arr)
        arrSum += x;

    return totalSum - arrSum;
}

int main() {
    int n = 5;
    vector<int> arr = {1, 2, 4, 5};

    cout << findMissingOptimal(arr, n);
}
```

### Complexity

* Time: **O(n)**
* Space: **O(1)**

---

# 4. Most Optimal Approach (XOR Method)

## Idea

Properties of XOR:

* `x ^ x = 0`
* `x ^ 0 = x`

So:

```
(1 ^ 2 ^ 3 ^ … ^ n) ^ (array elements) = missing number
```

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int findMissingXOR(vector<int>& arr, int n) {
    int xor1 = 0, xor2 = 0;

    for (int i = 1; i <= n; i++)
        xor1 ^= i;

    for (int x : arr)
        xor2 ^= x;

    return xor1 ^ xor2;
}

int main() {
    int n = 5;
    vector<int> arr = {1, 2, 4, 5};

    cout << findMissingXOR(arr, n);
}
```

### Complexity

* Time: **O(n)**
* Space: **O(1)**
* Safer than sum method (no overflow)

---

# Final Comparison

| Approach           | Time  | Space | Notes               |
| ------------------ | ----- | ----- | ------------------- |
| Brute              | O(n²) | O(1)  | Very basic          |
| Better (hashing)   | O(n)  | O(n)  | Uses extra space    |
| Optimal (sum)      | O(n)  | O(1)  | May overflow        |
| Most Optimal (XOR) | O(n)  | O(1)  | Best for interviews |

---


# Maximum Consecutive Ones

## Problem

Given a binary array (only 0s and 1s), find the **maximum number of consecutive 1s**.

### Example

```
Input:  [1, 1, 0, 1, 1, 1]
Output: 3
```

---

# 1. Brute Force Approach

## Idea

For each index:

* If it is 1 → count consecutive 1s ahead.
* Keep track of maximum.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int maxConsecutiveOnesBrute(vector<int>& arr) {
    int n = arr.size();
    int maxCount = 0;

    for (int i = 0; i < n; i++) {
        if (arr[i] == 1) {
            int count = 0;
            for (int j = i; j < n && arr[j] == 1; j++) {
                count++;
            }
            maxCount = max(maxCount, count);
        }
    }

    return maxCount;
}

int main() {
    vector<int> arr = {1, 1, 0, 1, 1, 1};
    cout << maxConsecutiveOnesBrute(arr);
}
```

### Complexity

* Time: **O(n²)**
* Space: **O(1)**

---

# 2. Optimal Approach (Single Pass)

## Idea

Traverse once:

* If element is 1 → increase count
* If element is 0 → reset count
* Track maximum

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

int maxConsecutiveOnesOptimal(vector<int>& arr) {
    int count = 0;
    int maxCount = 0;

    for (int x : arr) {
        if (x == 1) {
            count++;
            maxCount = max(maxCount, count);
        } else {
            count = 0;
        }
    }

    return maxCount;
}

int main() {
    vector<int> arr = {1, 1, 0, 1, 1, 1};
    cout << maxConsecutiveOnesOptimal(arr);
}
```

---

## Complexity

* Time: **O(n)**
* Space: **O(1)**

---

# Dry Run Example

Array:

```
1 1 0 1 1 1
```

Step-by-step:

| Element | Count | Max |
| ------- | ----- | --- |
| 1       | 1     | 1   |
| 1       | 2     | 2   |
| 0       | 0     | 2   |
| 1       | 1     | 2   |
| 1       | 2     | 2   |
| 1       | 3     | 3   |

Final Answer: **3**

---

# Interview Notes

* Very common question.
* Tests basic array traversal.
* Important for sliding window problems later.
* If question allows flipping one 0 → becomes sliding window variation.

---

